/**
 * API endpoint for Syllabus Bot
 * Course assistant for students and instructors
 *
 * POST actions:
 * - initConversation: Initialize a new syllabus bot conversation
 * - sendMessage: Send a message to the bot
 * - endConversation: End and cleanup the conversation
 *
 * GET loader:
 * - Returns org config for the syllabus bot (enabled status, etc.)
 *
 * SECURITY: Uses signed WebSocket connection via aiAgentConnection.server.js
 * All payloads are HMAC-signed before being sent to ai-agent service.
 */

import { assertClassroomAccess } from '~/utils/helpers';
import { isAIAgentConfigured } from '~/utils/aiFeatures.server';
import { getContentRepoName } from '@classmoji/utils';
import { sendRequest } from '~/services/aiAgentConnection.server';
import agentStreamManager from '~/utils/agentStreamManager';
import { v4 as uuidv4 } from 'uuid';
import { getInstallationToken } from '~/routes/student.$class.quizzes/helpers.server';
import { ClassmojiService } from '@classmoji/services';

// Helper to create JSON responses
const jsonResponse = (data, status = 200) =>
  new Response(JSON.stringify(data), {
    status,
    headers: { 'Content-Type': 'application/json' },
  });

/**
 * GET loader - return org config for syllabus bot
 * Used to check if syllabus bot is enabled and get suggested questions
 */
export async function loader({ params, request }) {
  const { class: classSlug } = params;

  // Verify user has access to the org (any role can use syllabus bot)
  const { classroom, membership } = await assertClassroomAccess({
    request,
    classroomSlug: classSlug,
    allowedRoles: ['OWNER', 'TEACHER', 'ASSISTANT', 'STUDENT'],
    resourceType: 'SYLLABUS_BOT',
    attemptedAction: 'check_config',
  });

  // If AI agent is not configured, report as disabled
  if (!isAIAgentConfigured()) {
    return jsonResponse({
      enabled: false,
      hasContentRepo: false,
      userRole: membership.role,
      isInstructor: ['OWNER', 'TEACHER'].includes(membership.role),
      orgName: classroom.name,
    });
  }

  const settings = await ClassmojiService.classroom.getClassroomSettingsForServer(classroom.id);
  const isInstructor = ['OWNER', 'TEACHER'].includes(membership.role);

  // Check if we have a content repo (either explicitly set or can be derived)
  const contentRepoName = getContentRepoName({
    login: classroom.git_organization?.login,
    term: classroom.term,
    year: classroom.year,
  });

  return jsonResponse({
    enabled: settings?.syllabus_bot_enabled ?? false,
    hasContentRepo: Boolean(contentRepoName),
    userRole: membership.role,
    isInstructor,
    orgName: classroom.name,
    courseName: settings?.course_name,
    term: classroom.term,
    slidesUrl: process.env.SLIDES_URL || 'http://localhost:6500',
  });
}

export async function action({ params, request }) {
  const { class: classSlug } = params;
  const formData = await request.formData();
  const _action = formData.get('_action');

  if (!isAIAgentConfigured()) {
    return jsonResponse({ error: 'AI features are not configured' }, 503);
  }

  switch (_action) {
    case 'initConversation':
      return handleInitConversation(request, classSlug, formData);
    case 'sendMessage':
      return handleSendMessage(request, classSlug, formData);
    case 'endConversation':
      return handleEndConversation(request, classSlug, formData);
    default:
      return jsonResponse({ error: `Unknown action: ${_action}` }, 400);
  }
}

/**
 * Initialize a syllabus bot conversation
 *
 * NOTE: Unlike quiz sessions, the conversationId is generated by ai-agent (from AIConversation.id).
 * Webapp receives this ID in the SYLLABUS_BOT_READY response and registers SSE stream afterward.
 */
async function handleInitConversation(request, classSlug, formData) {
  // Verify user has access (any role can use syllabus bot)
  const { userId, classroom, membership } = await assertClassroomAccess({
    request,
    classroomSlug: classSlug,
    allowedRoles: ['OWNER', 'TEACHER', 'ASSISTANT', 'STUDENT'],
    resourceType: 'SYLLABUS_BOT',
    attemptedAction: 'init_conversation',
  });

  const settings = await ClassmojiService.classroom.getClassroomSettingsForServer(classroom.id);

  // Check if syllabus bot is enabled
  if (!settings?.syllabus_bot_enabled) {
    return jsonResponse({ error: 'Syllabus bot is not enabled for this course' }, 403);
  }

  // Use URL-based role context if provided, otherwise fall back to membership role
  // This allows owners visiting /student/... to be treated as students
  const contextRole = formData.get('userRole') || membership.role;

  // Build org context for the bot
  const orgConfig = {
    orgId: classroom.id.toString(),
    classroomSlug: classSlug,
    gitOrgLogin: classroom.git_organization?.login, // GitHub org for content repo cloning
    orgName: classroom.name,
    courseName: settings?.course_name || classroom.name,
    term: classroom.term || 'Current',
    userRole: contextRole,
  };

  // Build payload for ai-agent (no conversationId - ai-agent generates it)
  const payload = {
    userId: userId.toString(),
    orgConfig,
    llmConfig: {
      anthropicApiKey: settings?.anthropic_api_key,
      model: settings?.syllabus_bot_model || settings?.llm_model,
    },
  };

  // If content repo is configured, add clone info
  // Use settings override or generate from classroom/git_org
  const contentRepoNameForClone = settings?.content_repo_name || getContentRepoName({
    login: classroom.git_organization?.login,
    term: classroom.term,
    year: classroom.year,
  });
  if (contentRepoNameForClone && classroom.git_organization?.github_installation_id) {
    try {
      const accessToken = await getInstallationToken(classroom.git_organization);
      payload.contentRepoName = contentRepoNameForClone;
      payload.accessToken = accessToken;
    } catch (error) {
      console.warn('[syllabus-bot] Failed to get installation token:', error.message);
      // Continue without content repo - bot will still work with database tools
    }
  }

  try {
    // Initialize conversation via signed ai-agent connection
    // ai-agent creates the conversation and generates the conversationId
    const result = await sendRequest('SYLLABUS_BOT_INIT', payload, {
      timeout: 300000, // 5 min timeout for content repo cloning + exploration
      responseTypes: ['SYLLABUS_BOT_READY'],
    });

    // Get the ai-agent-generated conversationId from response
    const conversationId = result.payload.conversationId;

    // NOW register for SSE stream (after we have the real conversationId)
    agentStreamManager.registerSession(conversationId, classSlug, userId);

    return jsonResponse({
      success: true,
      conversationId, // Use ai-agent's ID
      welcomeMessage: result.payload.welcomeMessage,
      hasContentRepo: result.payload.hasContentRepo,
      suggestedQuestions: result.payload.suggestedQuestions,
    });
  } catch (error) {
    console.error('[syllabus-bot] Init failed:', error);
    return jsonResponse({ error: error.message }, 500);
  }
}

/**
 * Send message to syllabus bot
 *
 * This uses sendRequest with SYLLABUS_BOT_MESSAGE type.
 * The response comes via WebSocket and is published to stream manager.
 */
async function handleSendMessage(request, classSlug, formData) {
  const conversationId = formData.get('conversationId');
  const content = formData.get('content');

  // Verify user has access
  await assertClassroomAccess({
    request,
    classroomSlug: classSlug,
    allowedRoles: ['OWNER', 'TEACHER', 'ASSISTANT', 'STUDENT'],
    resourceType: 'SYLLABUS_BOT',
    attemptedAction: 'send_message',
  });

  if (!conversationId || !content) {
    return jsonResponse({ error: 'Missing conversationId or content' }, 400);
  }

  try {
    const messageId = uuidv4();

    // Stream handler for exploration steps during message processing
    const onStreamData = step => {
      console.log('[syllabus-bot] Publishing exploration step:', step?.action);
      agentStreamManager.publishStep(conversationId, step);
    };

    // Send message via signed connection and wait for response
    const result = await sendRequest(
      'SYLLABUS_BOT_MESSAGE',
      { conversationId, content, messageId },
      {
        timeout: 300000, // 5 min timeout for LLM response + exploration
        responseTypes: ['SYLLABUS_BOT_RESPONSE'],
        onStreamData,
      }
    );

    // Publish the response to stream manager for SSE delivery
    // Use publishAssistantResponse (type: 'assistant_response') which the frontend hook expects
    agentStreamManager.publishAssistantResponse(conversationId, {
      content: result.payload.content,
      references: result.payload.references,
      explorationSteps: result.payload.explorationSteps,
    });

    return jsonResponse({ success: true, messageId });
  } catch (error) {
    console.error('[syllabus-bot] Send message failed:', error);
    agentStreamManager.publishError(conversationId, error);
    return jsonResponse({ error: error.message }, 500);
  }
}

/**
 * End syllabus bot conversation
 *
 * Sends SYLLABUS_BOT_END to cleanup resources on ai-agent side.
 * Similar to QUIZ_END, we don't wait for a response.
 */
async function handleEndConversation(request, classSlug, formData) {
  const conversationId = formData.get('conversationId');

  // Verify user has access
  await assertClassroomAccess({
    request,
    classroomSlug: classSlug,
    allowedRoles: ['OWNER', 'TEACHER', 'ASSISTANT', 'STUDENT'],
    resourceType: 'SYLLABUS_BOT',
    attemptedAction: 'end_conversation',
  });

  if (!conversationId) {
    return jsonResponse({ error: 'Missing conversationId' }, 400);
  }

  try {
    // Send end message via signed connection (no response expected)
    await sendRequest('SYLLABUS_BOT_END', { conversationId }, {
      timeout: 5000,
      responseTypes: [], // Don't wait for response
    });

    // Cleanup stream manager
    agentStreamManager.publishDone(conversationId);

    return jsonResponse({ success: true });
  } catch (error) {
    console.error('[syllabus-bot] End conversation failed:', error);
    return jsonResponse({ error: error.message }, 500);
  }
}
